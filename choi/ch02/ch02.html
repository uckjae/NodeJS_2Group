<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ch2</title>
<script>
// 기존 ES5
var num =1;
var num2 =2;
var result =3;
var string1 = num +'더하기'+num2+'는'+result;
console.log(string1);
//ES2015
const num3=1;
const num4=2;
const result2=3;
const string2=`${num3}더하기${num4}는'${result2}'`
console.log(string2);


//2.1.3 객체리터럴
var sayNode = function(){
    console.log('Node');
};
var es='Es5';
var oldObject={
    sayJS:function(){
        console.log('JS');
    },
    sayNode : sayNode,
};
oldObject[es+6]='Fantastic';
//re
const newObject={
    sayJS(){
        Console.log('JS');
    },
    sayNode,
    [es+6]:'Fantastic',
};


//2.1.4 화살표 함수
function add1(x,y){
    return x+y;
}
const add2=(x,y)=>{
    return x+y;
};
const add3=(x,y)=>x+y;
const add4=(x,y)=>(x+y);
//this 바인드
var relationship1={
    name:'zero',
    friends:['nero','hero','xero'],
    logFrinends:function(){
    var that =this; //-릴레이션을 가르키는 this를 that에 저장
    this.friends.forEach(function(friend){
    console.log(this.name,friend);
    });
    },
};
//re
const relationship2={
    name:'zero',
    friends:['nero','hero','xero'],
    logFrinends(){
        this.friends.forEach(friend=>{
            console.log(this.name,friend);

        });
    },
};


//2.1.5 비구조화 할당
/*
var candyMachine={
    status:{
        name:'node',
        count:5,
    },
    getCandy:function(){
        this.status.count--;
        return this.status.count;
    }
};
var getCandy = candyMachine.getCandy;
var count= candyMachine.status.count;
//re
const candyMachine={
    sstatus:{
        name:'node',
        count:5,
    },
    getCandy:function(){
        this.status.count--;
        return this.status.count;
    }
};
const { getCandy,status:{count}}=candyMachine;
*/


//2.1.6 프로미스(ES2015부터는 api들이 콜백대신 프로미스기반으로 재구성된다. 따라서 악명높은 콜백헬을 극복했다는 평을 받고있음)
const condition =true; //t면 resolve, f면 reject
const promise = new Promise((resolve, reject)=>{
    if(condition){
        resolve('성공');
    }else{
        reject('실패');
    }
});

promise
.then((message)=>{
console.log(message);
})
.catch((error)=>{
console.error(error);
})
//-여기서 then,catch를 다시 가능
promise
.then((message)=>{
return new Promise((resolve,reject)=>{
    resolve(message);
});
})
.then((message2)=>{
 console.log(message2);
return new Promise((resolve,reject)=>{
    resolve(message2);
});
})
.then((message3)=>{
 console.log(message3);
})
.catch((error)=>{
console.error(error);
});


//2.1.7 async/ aswait (ES2017에서 작동, 프로미스를 한번더 줄여준다)

//******2.2 프런트엔드 자바스크립트***********
//2.2.1 AJAX(비동기적 웹서비스 개발위한 기법, json, 요약:페이지이동없이 서버에 요청보내 응답받는 기술, 보통은 jquery, axios 라이브러리 이용해 보냄)
var xhr = new XMLHttpRequest();
xhr.onreadystatechange=function(){ //요청에 대한 콜백
if(xhr.readyState===xhr.DONE){//요청이 완료되면
if(xhr.status===200||xhr.status===201){
    console.log(xhr.responseText);//서버에서 보내주는값
}else{
    console.error(xhr.responseText);
}
}
};
xhr.open('GET','http://www.zerocho.com/api/get');
xhr.send();
//onload 와 onerror
var xhr = new XMLHttpRequest();
xhr.onload=function(){ //요청에 대한 콜백
if(xhr.status===200||xhr.status===201){
    console.log(xhr.responseText);//서버에서 보내주는값
}
};
xhr.onerror=function(){
    console.error(xhr.responseText);
};
xhr.open('GET','http://www.zerocho.com/api/get');
xhr.send();
</script>
</head>
<body>
</body>
</html>